// HTTP 协议的不足：通信使用明文（不加密），内容可能会被窃听；不验证通信方的身份，因此有可能遭遇伪装；无法证明报文的完整性，所以有可能已遭篡改
// 总结即： 内容未加密   内容无完整性证明， 无验证对方身份 
// HTTP 使用的认证方式： 
// BASIC 认证（基本认证） 对用户名 密码采用 Base64 编码处理，（非加密的处理方式）
// DIGEST 认证（摘要认证） 发送认证要求  服务器返回质询码  生成并发送响应码
// SSL 客户端认证  FormBase 认证（基于表单认证）  安装客户端证书  发送客户端证书信息  接受信息开始通信
// SSL 一般和 表单认证 组合使用，前者认证客户端计算机，后者认证本人信息
// BASIC 和 DIGEST 认证安全性不高， SSL 耗资源及费用 导致 现阶段多半是基于 表单认证的比较多

// 基本认证，摘要认证，报文完整性保护（摘要 qop="auth-int"）等识别 和 认证用户的 HTTP 特性，只有在友好的环境中用用， 商用的话，还是不够安全。
// 此时 HTTP 和 数字加密技术 更为安全
// 使用HTTPS 时，所有的 HTTP请求和响应数据 在发送到网络前都要 进行加密

// 1. 加秘：
// 数字加密
// 加密之前的报文被称为 明文（解码器转换）， 加密之后的报文被称为 密文（编码器转换）
// 每一台密码机都有不同的 '密钥'，要在密码机中输入正确的 '密钥'(盘号设置，就电影里的那些破解密码桥段)，解密过程才能正确进行。

// 加密算法，就是 ‘循环位移N字符’ （例如 A 位移 3位，得D。就由 D代替 A 输出），其中N 值由 '密钥' 来控制。。
// 编解码都是众所周知的，所以密钥就是唯一需要保密的东西了。
// 现代 数字密码 的编解码 是这样的： 由 编码函数 和 一个编码密钥 将 '明文' 经过编码后生成 密文，解码函数 和 一个解码密钥 将 '秘文' 经过解码后生成 明文。

// 对称密钥加密技术，即 发送端和接收端 要 共享 相同的 密钥 才能进行通信。缺点是每个客户端都产生 一个共享密钥，这样会产生大量的保密密钥。。
// 长密钥技术，即 密钥的位数 来生成大量的密钥值，使得通过 暴力枚举法 都无法破解密钥。。其中 128位的 DES密钥 需要花费 10 的十几次方年
// 公开密钥加密技术，即 无需为每对主机设置 '单独的' 加密/解密密钥，而是客户端都使用 公开的密钥(用来编码)，但解码密钥（用来解码）是保密的，即只有服务端才能解密。
// 共享密钥需要用到 RSA 算发。。
// 共享加密技术可能会慢一些，通常的做法是， 通过 公开密钥 加密技术建立安全通信，然后再通过这条安全通道产生并发送 对称密钥
// HTTPS 采用 共享密钥加密 和 公开密钥加密 两者并用的混合加密机制

// 2. 完整性保护
// 数字签名： 附加在报文上的特殊加密校验码。用以说明谁写了报文，同时证明报文未被篡改过。。
// 经过私钥加密的数据，只有通过公钥才可以解密出来，反之亦然。 私钥自己保留，公钥用于发放给别人
// 客户端A 有 服务端B 的公钥， 客户端A 使用 服务端B 的公钥加密消息 并发送消息到 服务端B， 服务端B 发送数据前对数据进行 Hash 运算，然后使用私钥加密，加密的结果叫 数字签名。然后 服务端B 把数据随同签名 发送给 客户端A，
// 客户端A 通过 服务端B 的公钥获得 两个信息： 1. 通过公钥成功解密，确定是 服务端B    2.对传输的数据进行 Hash 运算，确定内容有没有被篡改过。

// 3. 认证
// 数字证书：    证明公开密钥正确性的证书  数字认证机构的工作流程。。。。？？？
// 此时有个中间人 C 截取通信， 将 服务端B 发给 客户端A 的公钥换成自己的公钥，则导致 客户端A 把 C 当成了 服务端B，此时 客户端A 使用了 C 的公钥加密发送消息给 C， C再使用自己的私钥获取消息内容，
// C 再使用 服务端B 的公钥加密消息，并发送给 服务端B， 服务端B却以为是 A 发来的。 过程中 C 其实是冒充了 客户端A B的角色，使得 A B 都错把 C 当成了对方。
// 此时数字证书确保 客户端A 拿到的是 服务端B 的公钥，而不是 C 的。  证书机构 CA 使用自己的私钥对 服务端B 的公钥进行加密，生成证书 发给服务端B，

// 客户端验证证书：
// 客户端A 在建立 HTTPS链接后 自动得到证书，客户端A 得到 '证书的公钥'（通过CA或其它途径），客户端A 用 '证书的公钥'对证书中的数字签名解密，得到哈希值，客户端对 '服务端B 的公钥' 进行哈希值计算，两个哈希值对比，如果相同，则证书合法。
// 之后再进行数字签名的一系列验证。。

// HTTPS     通信的加密： 安全套接层 SSL  传输层安全 TLS
// 就是在将 HTTP 报文发送给 TCP 前，将其发送了一个 安全层 SSL，对其进行了加密
// 在发送加密的报文前，客户端和服务端需要进行一次 SSL握手，即打开一条端口号为 443 的连接，
// 客户端先发送一条端口号为 443 的连接，在发送加密的请求报文前，客户端和服务端需要进行一次 SSL握手（此过程就是对 数字证书 的认证），然后才发送已加密的请求，服务端返回已加密的响应， SSL 关闭，TCP关闭。
// SSL -> 密文 -> 认证 -> 发送加密请求  ( SSL 是当今世界上应用最为广泛的网络安全技术 )
// 使用 SSL 加速器这种（专用服务器）硬件来改善  SSL 通信的慢的问题

// HTTP+ 加密 + 认证 + 完整性保护 =HTTPS
// HTTPS 通信步骤和机制
// 通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP

// OpenSSL 开源库 实现 HTTPS 客户端。 即产生 由自认证机构颁发的证书， 是不被浏览器认可的

// HTTPS  加密解密会消耗更多的 CPU及内存资源， 购买证书的开销也是原因之一